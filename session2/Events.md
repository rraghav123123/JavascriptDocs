
# [Events](https://developer.mozilla.org/en-US/docs/Web/API/Event)
An event occurs when something happens in a browser window. Some examples of events are: 
- A document loading
- The user clicking a mouse button
- The browser screen changing size## Event Handling

The `Event` interface represents any event which takes place in the DOM; some are user-generated (such as mouse or keyboard events), while others are generated by APIs (such as events that indicate an animation has finished running, a video has been paused, and so forth). 
More on that over [here](https://developer.mozilla.org/en-US/docs/Web/API/Event).

When a function is assigned to an event handler, that function is executed when that event occurs.

**For example:**
```
document.onclick = clickHandler;
```
This handler will cause the function `clickHandler()` to be executed whenever the user clicks the mouse anywhere on the screen.  The `clickHandler()` function is defined like this:

```
function clickHandler(event) {
  //some code here
}
```
When an event handler is assigned, the function name does not end with parentheses. We are just pointing the event to the name of the function.

## Event Object	

Whenever an event fires, the computer places appropriate data about the event into the event object - for example, where the mouse pointer was on the screen at the time of the event, which mouse buttons were being pressed at the time of the event, and other useful information.

The properties of the event object covered in this article are listed in the following table.
|Event Object Property|Description|
|--|--|
|SrcElement|The element that fired the event|
|type |Type of event|
|returnValue|Determines whether the event is cancelled|
|cancelBubble|Can cancel an event bubble|
|clientX|Mouse pointer X coordinate relative to window|
|clientY|Mouse pointer Y coordinate relative to window|
|offsetX|Mouse pointer X coordinate relative to element that fired the event|
|offsetY|Mouse pointer Y coordinate relative to element that fired the event|
|button|Any mouse buttons that are pressed  |
|altKey|True if the alt key was also pressed  |
|ctrlKey|True if the ctrl key was also pressed  |
|shiftKey|True if the shift key was also pressed  |
|keyCode|Returns UniCode value of key pressed  |

Once we have received an event, we may need to know more about it, and this is the primary purpose of the event object.

More info on the event object can be found [here](https://www.htmlgoodies.com/beyond/javascript/events-and-javascript-part-3-the-event-object.html) and [here](https://www.w3schools.com/jsref/dom_obj_event.asp).

## Event Bubbling and Capturing

### Bubbling
Let’s start with an example.

```
<div onclick="alert('The handler!')">
  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>
</div>
```

This handler is assigned to `<div>`, but also runs if you click any nested tag like `<em>` or `<code>`.

Why does the handler on `<div>` runs if the actual click was on `<em>`?

This is due to the bubbling principle is simple.

*When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.*

### Capturing

One of the main things to note is that it doesn't matter where in your DOM you initiate an event. The event always starts at the root, goes down until it hits the target, and then goes back up to the root. This entire journey is very formally defined, so let's look at all of this formalness.

The part where you initiate the event and the event barrels down the DOM from the root is known as the *Event Capturing Phase*.

![enter image description here](https://www.kirupa.com/html5/images/capture_phase_72.png)

The standard DOM Events describes 3 phases of event propagation:

Capturing phase – the event goes down to the element.
Target phase – the event reached the target element.
Bubbling phase – the event bubbles up from the element.

![enter image description here](https://javascript.info/article/bubbling-and-capturing/eventflow@2x.png)
*Picture of a click on `<td>` inside a table, based on the specification*

For a click on `<td>` the event first goes through the ancestors chain down to the element (capturing), then it reaches the target, and then it goes up (bubbles), calling handlers on its way.

To catch an event on the capturing phase, we need to set the 3rd argument of `addEventListener` to true.

There are two possible values for that optional last argument:

- If it’s false (default), then the handler is set on the bubbling phase.
- If it’s true, then the handler is set on the capturing phase.

##### Example 
Sample Code
```
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Capturing: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Bubbling: ${elem.tagName}`));
  }
</script>

```

## Event Delegation

Event delegation allows us to attach a single event listener, to a parent element, that will fire for all descendants matching a selector, whether those descendants exist now or are added in the future.

The idea is that if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them – we put a single handler on their common ancestor.

##### Example

Let's say that we have a parent UL element with several child elements:

```
<ul id="parent-list">
	<li id="post-1">Item 1</li>
	<li id="post-2">Item 2</li>
	<li id="post-3">Item 3</li>
	<li id="post-4">Item 4</li>
	<li id="post-5">Item 5</li>
	<li id="post-6">Item 6</li>
</ul>
```

Let's say that something needs to happen when each child element is clicked. We could add a separate event listener to each individual `LI` element, but what if `LI` elements are frequently added and removed from the list?  

Adding and removing event listeners would be a nightmare, especially if addition and removal code is in different places within your app.  The better solution is to add an event listener to the parent `UL` element.  

But if we add the event listener to the parent, how will we know which element was clicked?

When the event bubbles up to the `UL` element, you check the event object's target property to gain a reference to the actual clicked node. 

```
// Get the element, add a click listener...
document.getElementById("parent-list").addEventListener("click", function(e) {
	// e.target is the clicked element!
	// If it was a list item
	if(e.target && e.target.nodeName == "LI") {
		// List item found!  Output the ID!
		console.log("List item ", e.target.id.replace("post-", ""), " was clicked!");
	}
});
```
We start by adding a `click` event listener to the parent element.  When the event listener is triggered, check the event element to ensure it's the type of element to react to.  If it is an `LI` element,  we have what we need!  If it's not an element that we want, the event can be ignored. 

More on the topic over [here](https://javascript.info/event-delegation).

